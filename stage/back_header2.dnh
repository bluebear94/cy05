// background

#include "./../prologue.dnh"

let done = false;

/*
txIndex: a list of file paths
objects:
	1 Entry ->
		[texture index, vertex count, type]
		[x, y, z, u, v, alpha, red, green, blue] (as many as the vertex count)
fog: [start, end, red, green, blue]
sky: path to sky texture
customBehavior(): task for custom control of objects
Possible mesh support?
*/

// 1 - top left
// 2 - top right
// 3 - bottom right
// 4 - bottom left
function rectangular(txi, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, uv) {
	return [
		[txi, 4, PRIMITIVE_TRIANGLEFAN],
		[x1, y1, z1, 0, 0, 255, 255, 255, 255],
		[x2, y2, z2, uv, 0, 255, 255, 255, 255],
		[x3, y3, z3, uv, uv, 255, 255, 255, 255],
		[x4, y4, z4, 0, uv, 255, 255, 255, 255]
	];
}

let primitives = [];

@Initialize {
	// stub
	let l = length(objects);
	ascent (i in 0 .. l) {
		let prim = ObjPrim_Create(OBJ_PRIMITIVE_3D);
		primitives = primitives ~ [prim];
		let def = objects[i];
		let header = def[0];
		let txi = header[0];
		let vc = header[1];
		let type = header[2];
		ObjPrim_SetTexture(prim, txIndex[txi]);
		ObjPrim_SetPrimitiveType(prim, type);
		ObjPrim_SetVertexCount(prim, vc);
		ascent(j in 0 .. vc) {
			let vdef = def[j + 1];
			ObjPrim_SetVertexPosition(prim, j, vdef[0], vdef[1], vdef[2]);
			ObjPrim_SetVertexUV(prim, j, vdef[3], vdef[4]);
			ObjPrim_SetVertexAlpha(prim, j, vdef[5]);
			ObjPrim_SetVertexColor(prim, j, vdef[6], vdef[7], vdef[8]);
		}
		ObjRender_SetBlendType(prim, BLEND_ALPHA);
		Obj_SetRenderPriority(prim, 0.22);
	}
	if (length(fog) == 0) {SetFogEnable(false);}
	else {
		SetFogEnable(true);
		SetFogParam(fog[0], fog[1], fog[2], fog[3], fog[4]);
	}
	let bg = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(bg, sky);
	ObjSprite2D_SetSourceRect(bg, 0, 0, GetStgFrameWidth, GetStgFrameHeight);
	ObjSprite2D_SetDestRect(bg, 0, 0, GetStgFrameWidth, GetStgFrameHeight);
	Obj_SetRenderPriority(bg, 0.21);
	customBehavior;
	debug;
}

task debug {
	let data = [
		[1000, 0, 0, 255, 0, 0],
		[0, 1000, 0, 0, 255, 0],
		[0, 0, 1000, 0, 0, 255],
		[-1000, 0, 0, 0, 255, 255],
		[0, -1000, 0, 255, 0, 255],
		[0, 0, -1000, 255, 255, 0]
	];
	let l = length(data);
	ascent (i in 0 .. l) {
		let axis = ObjPrim_Create(OBJ_PRIMITIVE_3D);
		let d = data[i];
		ObjPrim_SetPrimitiveType(axis, PRIMITIVE_LINELIST);
		ObjPrim_SetVertexCount(axis, 2);
		ObjPrim_SetVertexPosition(axis, 0, 0, 0, 0);
		ObjPrim_SetVertexPosition(axis, 1, d[0], d[1], d[2]);
		ascent (j in 0 .. 2) {
			ObjPrim_SetVertexColor(axis, j, d[3], d[4], d[5]);
		}
		ObjRender_SetBlendType(axis, BLEND_ALPHA);
	}
	let text = ObjText_Create;
	ObjRender_SetPosition(text, 0, 0, 0);
	ObjText_SetFontType(text, typeface);
	ObjText_SetFontColorTop(text, 255, 255, 255);
	ObjText_SetFontColorBottom(text, 255, 255, 255);
	ObjText_SetFontBorderType(text, BORDER_FULL);
	ObjText_SetFontBorderWidth(text, 2);
	ObjText_SetFontBorderColor(text, 0, 0, 0);
	while (!IsCloseScript(GetOwnScriptID)) {
		SetPlayerInvincibilityFrame(99999);
		function pr(k) {
			return GetKeyState(k) == KEY_HOLD;
		}
		ObjText_SetText(text,
			"X " ~ ToString(GetCameraFocusX) ~
			"[r]Y " ~ ToString(GetCameraFocusY) ~
			"[r]Z " ~ ToString(GetCameraFocusZ) ~
			"[r]pitch " ~ ToString(GetCameraPitch) ~
			"[r]roll " ~ ToString(GetCameraRoll) ~
			"[r]yaw " ~ ToString(GetCameraYaw) ~
			"[r]azimuth " ~ ToString(GetCameraAzimuthAngle) ~
			"[r]elevation " ~ ToString(GetCameraElevationAngle)
		);
		if (pr(KEY_W)) {
			SetCameraFocusZ(GetCameraFocusZ + 1);
		}
		else if (pr(KEY_S)) {
			SetCameraFocusZ(GetCameraFocusZ - 1);
		}
		else if (pr(KEY_A)) {
			SetCameraFocusX(GetCameraFocusX - 1);
		}
		else if (pr(KEY_D)) {
			SetCameraFocusX(GetCameraFocusX + 1);
		}
		else if (pr(KEY_T)) {
			SetCameraFocusY(GetCameraFocusY + 1);
		}
		else if (pr(KEY_G)) {
			SetCameraFocusY(GetCameraFocusY - 1);
		}
		else if (pr(KEY_Y)) {
			SetCameraElevationAngle(GetCameraElevationAngle - 1);
		}
		else if (pr(KEY_H)) {
			SetCameraElevationAngle(GetCameraElevationAngle + 1);
		}
		else if (pr(KEY_U)) {
			SetCameraRoll(GetCameraRoll - 1);
		}
		else if (pr(KEY_I)) {
			SetCameraRoll(GetCameraRoll + 1);
		}
		else if (pr(KEY_J)) {
			SetCameraYaw(GetCameraYaw - 1);
		}
		else if (pr(KEY_K)) {
			SetCameraYaw(GetCameraYaw + 1);
		}
		yield;
		
	}
}

@MainLoop {
	// stub
	let objScene = GetEnemyBossSceneObjectID();
	let inSpell = objScene != ID_INVALID && ObjEnemyBossScene_GetInfo(objScene, INFO_IS_SPELL);
	yield;
}

@Finalize {
	let l = length(primitives);
	ascent (i in 0 .. l) {
		Obj_Delete(primitives[i]);
	}
	done = true;
}
